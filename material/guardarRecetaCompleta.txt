PasosFragment.

private void guardarReceta() {
    viewModel.guardarRecetaCompleta();
    Toast.makeText(getContext(), "Receta guardada", Toast.LENGTH_SHORT).show();
    getActivity().finish();
}

Repositorio.
Es la capa encargada del acceso a datos.(DB / ficheros / red). 
En este caso, guardar en local el archivo de imagen.

private String copiarImagenAlmacenamientoInterno(Uri uriTemp) {
        if (uriTemp == null) return null;
        
        try {
            
            // Crear nombre único
            String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault())
                    .format(new Date());
            String nombreArchivo = "RECETA_" + timeStamp + ".jpg";
            
            // Directorio privado de la app
            File directorio = new File(context.getFilesDir(), "imagenes_recetas");
            if (!directorio.exists()) {
                directorio.mkdirs();
            }
            
            File archivoDestino = new File(directorio, nombreArchivo);
            
            // Copiar archivo
            try (InputStream in = appContext.getContentResolver().openInputStream(uriTemp);
                 OutputStream out = new FileOutputStream(archivoDestino)) {
                
                byte[] buffer = new byte[1024];
                int length;
                while ((length = in.read(buffer)) > 0) {
                    out.write(buffer, 0, length);
                }
            }
            
            // Retornar path absoluto o URI
            return archivoDestino.getAbsolutePath();
            // O alternativamente: return Uri.fromFile(archivoDestino).toString();
            
        } catch (Exception e) {
            Log.e(TAG, "Error copiando imagen: " + e.getMessage());
            return null;
        }
    }
	
	    // Método para limpiar imágenes si falla la transacción
    public void eliminarImagen(String imagenPath) {
        if (imagenPath != null) {
            File imagenFile = new File(imagenPath);
            if (imagenFile.exists()) {
                imagenFile.delete();
            }
        }
    }
	
public void insertarRecetaCompleta(Receta receta, List<Ingrediente> ingredientes,
                                   List<Paso> pasos, Uri imagenUriTemp) {
    Recetario.servicioExecutor.execute(() -> {
        mdb.runInTransaction(() -> {

            // 1. Copiar imagen
            String imagenUriPersistente = copiarImagenAlmacenamientoInterno(imagenUriTemp);
            receta.setImagenUri(imagenUriPersistente);

            // 2. Insertar receta
            long recetaId = mRecetaDAO.insertarReceta(receta);
            receta.setIdReceta(recetaId);

            // 3. Ingredientes
            for (Ingrediente ing : ingredientes) {
                ing.setIdReceta(recetaId);
            }
            mIngredienteDAO.insertarIngredientes(ingredientes);

            // 4. Pasos
            int orden = 1;
            for (Paso paso : pasos) {
                paso.setIdReceta(recetaId);
                paso.setOrden(orden++);
            }
            mPasoDAO.insertarPasos(pasos);

        });
    });
}

    
	
	ViewModel 
	
    public void guardarRecetaCompleta() {
        repo.insertarRecetaCompleta(
                receta.getValue(),
                ingredientes.getValue(),
                pasos.getValue(),
                imagenUriTemp.getValue()
        );
    }
	--------------------------------------------- esperar para cerrar------------------
Paso 1 — Modificar el repositorio para aceptar un callback
public void insertarRecetaCompleta(Receta receta, 
                                   List<Ingrediente> ingredientes, 
                                   List<Paso> pasos, 
                                   Uri imagenUriTemporal,
                                   Runnable onFinish) {

    Recetario.servicioExecutor.execute(() -> {
        mdb.runInTransaction(() -> {

            // Guardar imagen
            String rutaFinalImagen = copiarImagenAlmacenamientoInterno(imagenUriTemporal);
            receta.setImagenUri(rutaFinalImagen);

            // Insertar receta
            long recetaId = mRecetaDAO.insertarReceta(receta);
            receta.setIdReceta(recetaId);

            // Ingredientes
            for (Ingrediente ing : ingredientes) {
                ing.setIdReceta(recetaId);
            }
            mIngredienteDAO.insertarIngredientes(ingredientes);

            // Pasos
            int orden = 1;
            for (Paso paso : pasos) {
                paso.setIdReceta(recetaId);
                paso.setOrden(orden++);
            }
            mPasoDAO.insertarPasos(pasos);
        });

        // Notificar cuando termine
        if (onFinish != null) onFinish.run();
    });
}

Paso 2 — ViewModel solo delega y reacciona

Declaramos LiveData:

private final MutableLiveData<Boolean> recetaGuardada = new MutableLiveData<>();
public LiveData<Boolean> getRecetaGuardada() { return recetaGuardada; }


Ahora guardarRecetaCompleta() no crea hilos, solo llama al repositorio:

public void guardarRecetaCompleta() {
    Receta r = receta.getValue();
    List<Ingrediente> ing = ingredientes.getValue();
    List<Paso> ps = pasos.getValue();
    Uri uri = imagenUriTemp.getValue();

    repo.insertarRecetaCompleta(r, ing, ps, uri, () -> {
        // Esto se ejecuta cuando el repo finaliza en background
        recetaGuardada.postValue(true);
    });
}

Paso 3 — PasosFragment observa el resultado
@Override
public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
    super.onViewCreated(view, savedInstanceState);

    viewModel.getRecetaGuardada().observe(getViewLifecycleOwner(), guardada -> {
        if (Boolean.TRUE.equals(guardada)) {
            Toast.makeText(getContext(), "Receta guardada", Toast.LENGTH_SHORT).show();
            requireActivity().finish();
        }
    });
}


Y el botón:

private void guardarReceta() {
    viewModel.guardarRecetaCompleta();  // No bloquea UI 
}

